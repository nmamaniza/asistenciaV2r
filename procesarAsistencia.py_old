#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script para procesar asistencia y generar registros en dailyattendances
Base de datos: asistenciaV2r
"""

import sys
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime, timedelta, time
import argparse

# Configuraci√≥n de conexi√≥n
DB_CONFIG = {
    'dbname': 'asistenciaV2r',
    'user': 'nestor',
    'password': 'Arequipa@2018',
    'host': '172.16.1.61',
    'port': 5432
}


def conectar_bd():
    """Establece conexi√≥n con la base de datos"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        return conn
    except Exception as e:
        print(f"Error al conectar a la base de datos: {e}")
        sys.exit(1)


def obtener_calendario(conn, fecha):
    """Verifica si existe calendario para la fecha"""
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("""
        SELECT id, fecha, estado, descripcion
        FROM calendardays
        WHERE fecha = %s
    """, (fecha,))
    return cursor.fetchone()


def obtener_usuarios_activos(conn, fecha, dni=None):
    """Obtiene usuarios con asignaciones activas en la fecha"""
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    
    sql = """
        SELECT DISTINCT 
            u.id as user_id,
            u.dni,
            u.nombre,
            u.apellidos,
            ja.id as jobassignment_id,
            ja.fechaini,
            ja.fechafin,
            ws.id as workschedule_id,
            ws.horaini,
            ws.horafin,
            ws.tolerancia_min
        FROM users u
        INNER JOIN jobassignments ja ON ja.user_id = u.id
        INNER JOIN workschedules ws ON ws.id = ja.workschedule_id
        WHERE ja.estado = 1
        AND ja.fechaini <= %s
        AND (ja.fechafin IS NULL OR ja.fechafin >= %s)
    """
    
    params = [fecha, fecha]
    
    if dni:
        sql += " AND u.dni = %s"
        params.append(dni)
    
    sql += " ORDER BY u.dni"
    
    cursor.execute(sql, params)
    return cursor.fetchall()


def obtener_marcaciones(conn, user_id, fecha):
    """Obtiene todas las marcaciones de un usuario en una fecha"""
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("""
        SELECT 
            id,
            fechahora,
            hora,
            tipo_marcaje
        FROM attendances
        WHERE user_id = %s
        AND fecha = %s
        AND estado = 1
        ORDER BY hora
    """, (user_id, fecha))
    return cursor.fetchall()


def obtener_permisos_lactancia(conn, user_id, fecha):
    """Obtiene informaci√≥n de permisos de lactancia activos"""
    cursor = conn.cursor(cursor_factory=RealDictCursor)
    cursor.execute("""
        SELECT 
            ls.modo,
            ls.minutos_diarios,
            p.id as permission_id
        FROM permissions p
        INNER JOIN permissiontypes pt ON pt.id = p.permissiontype_id
        INNER JOIN lactation_schedules ls ON ls.permission_id = p.id
        WHERE p.user_id = %s
        AND p.estado = 1
        AND pt.codigo = 'LACTANCIA'
        AND %s BETWEEN p.fechaini AND p.fechafin
        AND %s BETWEEN ls.fecha_desde AND ls.fecha_hasta
        AND ls.estado = 1
        LIMIT 1
    """, (user_id, fecha, fecha))
    return cursor.fetchone()


def calcular_horario_esperado(horario, lactancia):
    """Calcula horario esperado considerando lactancia"""
    horaini_esperada = horario['horaini']
    horafin_esperada = horario['horafin']
    
    if lactancia:
        if lactancia['modo'] == 'INICIO':
            # Llega una hora despu√©s
            dt = datetime.combine(datetime.today(), horaini_esperada)
            dt += timedelta(minutes=lactancia['minutos_diarios'])
            horaini_esperada = dt.time()
        elif lactancia['modo'] == 'FIN':
            # Sale una hora antes
            dt = datetime.combine(datetime.today(), horafin_esperada)
            dt -= timedelta(minutes=lactancia['minutos_diarios'])
            horafin_esperada = dt.time()
    
    return horaini_esperada, horafin_esperada


def calcular_asistencia(horario, marcaciones, lactancia, estado_calendario):
    """Calcula los campos de asistencia seg√∫n las reglas de negocio"""
    
    resultado = {
        'horaini': None,
        'horafin': None,
        'nummarca': len(marcaciones),
        'horaint': ','.join([str(m['hora']) for m in marcaciones]),
        'mintarde': 0,
        'retarde': 0,
        'horaslab': 0,
        'minlab': 0,
        'horas_extras': 0,
        'obs': '',
        'final': '',
        'minutos_lactancia': lactancia['minutos_diarios'] if lactancia else 0,
        'modo_lactancia': lactancia['modo'] if lactancia else None,
        'flaglab': 1 if estado_calendario == 1 else 0
    }
    
    # Si no hay marcaciones
    if not marcaciones:
        if estado_calendario == 1:  # D√≠a laborable
            resultado['obs'] = 'F'
            resultado['final'] = 'F'
        return resultado
    
    # Calcular horario esperado con lactancia
    horaini_esperada, horafin_esperada = calcular_horario_esperado(horario, lactancia)
    
    # Primera y √∫ltima marcaci√≥n
    primera_marca = marcaciones[0]['hora']
    ultima_marca = marcaciones[-1]['hora'] if len(marcaciones) > 1 else None
    
    # Solo procesar si es d√≠a laborable (estado=1)
    if estado_calendario != 1:
        # D√≠as no laborables: solo contar marcaciones
        resultado['horaint'] = ','.join([str(m['hora']) for m in marcaciones])
        if len(marcaciones) >= 2:
            # Calcular horas extras como diferencia entre primera y √∫ltima
            minutos = (datetime.combine(datetime.today(), ultima_marca) - 
                      datetime.combine(datetime.today(), primera_marca)).seconds // 60
            resultado['horas_extras'] = round(minutos / 60, 2)
        return resultado
    
    # D√≠a laborable (estado=1)
    tolerancia = horario['tolerancia_min']
    
    # Verificar ingreso
    if primera_marca <= horaini_esperada:
        resultado['horaini'] = primera_marca
    else:
        # Lleg√≥ tarde
        dt_esperada = datetime.combine(datetime.today(), horaini_esperada)
        dt_real = datetime.combine(datetime.today(), primera_marca)
        minutos_tarde = (dt_real - dt_esperada).seconds // 60
        
        if minutos_tarde <= tolerancia:
            resultado['horaini'] = primera_marca
            resultado['retarde'] = minutos_tarde
        else:
            resultado['mintarde'] = minutos_tarde
    
    # Verificar salida
    if ultima_marca and ultima_marca >= horafin_esperada:
        resultado['horafin'] = ultima_marca
        
        # Calcular horas extras
        dt_esperada = datetime.combine(datetime.today(), horafin_esperada)
        dt_real = datetime.combine(datetime.today(), ultima_marca)
        minutos_extras = (dt_real - dt_esperada).seconds // 60
        if minutos_extras > 0:
            resultado['horas_extras'] = round(minutos_extras / 60, 2)
    
    # Calcular horas laboradas
    if len(marcaciones) >= 2:
        dt_inicio = datetime.combine(datetime.today(), primera_marca)
        dt_fin = datetime.combine(datetime.today(), ultima_marca)
        resultado['minlab'] = (dt_fin - dt_inicio).seconds // 60
        resultado['horaslab'] = round(resultado['minlab'] / 60, 2)
    
    # Determinar obs y final
    tiene_ingreso = resultado['horaini'] is not None
    tiene_salida = resultado['horafin'] is not None
    
    if tiene_ingreso and tiene_salida and resultado['mintarde'] == 0:
        resultado['obs'] = 'A'
        resultado['final'] = 'A'
    elif not tiene_ingreso and not tiene_salida:
        if len(marcaciones) == 1:
            resultado['obs'] = 'FI-FS'
            resultado['final'] = 'FI-FS'
        else:
            resultado['obs'] = 'F'
            resultado['final'] = 'F'
    elif not tiene_ingreso:
        if resultado['retarde'] > 0:
            resultado['obs'] = f"{resultado['retarde']}"
            resultado['final'] = f"{resultado['retarde']}"
            if not tiene_salida:
                resultado['obs'] += ' - FS'
                resultado['final'] += ' - FS'
        else:
            resultado['obs'] = 'FI'
            resultado['final'] = 'FI'
    elif not tiene_salida:
        if resultado['retarde'] > 0:
            resultado['obs'] = f"{resultado['retarde']} - FS"
            resultado['final'] = f"{resultado['retarde']} - FS"
        else:
            resultado['obs'] = 'FS'
            resultado['final'] = 'FS'
    elif resultado['retarde'] > 0:
        resultado['obs'] = str(resultado['retarde'])
        resultado['final'] = str(resultado['retarde'])
    
    return resultado


def ya_procesado(conn, jobassignment_id, fecha):
    """Verifica si ya existe registro procesado"""
    cursor = conn.cursor()
    cursor.execute("""
        SELECT id FROM dailyattendances
        WHERE jobassignment_id = %s AND fecha = %s
    """, (jobassignment_id, fecha))
    return cursor.fetchone() is not None


def insertar_asistencia(conn, jobassignment_id, fecha, datos):
    """Inserta o actualiza registro en dailyattendances"""
    cursor = conn.cursor()
    
    sql = """
        INSERT INTO dailyattendances (
            jobassignment_id, fecha, anio, mes,
            horaini, horafin, nummarca, obs, mintarde, retarde,
            minutos_lactancia, modo_lactancia, final, horaint,
            flaglab, horaslab, minlab, horas_extras, estado,
            created_at
        ) VALUES (
            %s, %s, %s, %s,
            %s, %s, %s, %s, %s, %s,
            %s, %s, %s, %s,
            %s, %s, %s, %s, 1,
            CURRENT_TIMESTAMP
        )
        ON CONFLICT (jobassignment_id, fecha) DO UPDATE SET
            horaini = EXCLUDED.horaini,
            horafin = EXCLUDED.horafin,
            nummarca = EXCLUDED.nummarca,
            obs = EXCLUDED.obs,
            mintarde = EXCLUDED.mintarde,
            retarde = EXCLUDED.retarde,
            minutos_lactancia = EXCLUDED.minutos_lactancia,
            modo_lactancia = EXCLUDED.modo_lactancia,
            final = EXCLUDED.final,
            horaint = EXCLUDED.horaint,
            flaglab = EXCLUDED.flaglab,
            horaslab = EXCLUDED.horaslab,
            minlab = EXCLUDED.minlab,
            horas_extras = EXCLUDED.horas_extras,
            updated_at = CURRENT_TIMESTAMP
    """
    
    cursor.execute(sql, (
        jobassignment_id, fecha, fecha.year, fecha.month,
        datos['horaini'], datos['horafin'], datos['nummarca'], 
        datos['obs'], datos['retarde'], datos['mintarde'],
        datos['minutos_lactancia'], datos['modo_lactancia'], 
        datos['final'], datos['horaint'],
        datos['flaglab'], datos['horaslab'], datos['minlab'], 
        datos['horas_extras']
    ))


def procesar_fecha(conn, fecha, dni=None):
    """Procesa asistencia para una fecha espec√≠fica"""
    
    # 1. Verificar calendario
    calendario = obtener_calendario(conn, fecha)
    if not calendario:
        print(f"‚ö†Ô∏è  No hay calendario programado para {fecha}")
        return 0
    
    print(f"\nüìÖ Procesando fecha: {fecha} ({calendario['descripcion']})")
    print(f"   Estado del d√≠a: {calendario['estado']} (0=feriado, 1=laborable, 2=recuperable)")
    
    # 2. Obtener usuarios activos
    usuarios = obtener_usuarios_activos(conn, fecha, dni)
    if not usuarios:
        print(f"   No hay usuarios activos para procesar")
        return 0
    
    print(f"   Usuarios a procesar: {len(usuarios)}")
    
    procesados = 0
    
    for usuario in usuarios:
        # 3. Obtener marcaciones
        marcaciones = obtener_marcaciones(conn, usuario['user_id'], fecha)
        
        # 4. Obtener permisos de lactancia
        lactancia = obtener_permisos_lactancia(conn, usuario['user_id'], fecha)
        
        # 5. Calcular asistencia
        datos_asistencia = calcular_asistencia(
            usuario, 
            marcaciones, 
            lactancia,
            calendario['estado']
        )
        
        # 6. Insertar en dailyattendances
        try:
            insertar_asistencia(
                conn, 
                usuario['jobassignment_id'], 
                fecha, 
                datos_asistencia
            )
            procesados += 1
            
            # Mostrar resumen
            marca_info = f"{datos_asistencia['nummarca']} marcas"
            if datos_asistencia['horaini']:
                marca_info += f" | In: {datos_asistencia['horaini']}"
            if datos_asistencia['horafin']:
                marca_info += f" | Sal: {datos_asistencia['horafin']}"
            if datos_asistencia['obs']:
                marca_info += f" | {datos_asistencia['obs']}"
            
            print(f"   ‚úì {usuario['dni']} - {usuario['nombre']}: {marca_info}")
            
        except Exception as e:
            print(f"   ‚úó Error procesando {usuario['dni']}: {e}")
            conn.rollback()
            continue
    
    conn.commit()
    return procesados


def main():
    parser = argparse.ArgumentParser(
        description='Procesar asistencia de personal'
    )
    parser.add_argument(
        '--fecha-inicio',
        type=str,
        help='Fecha de inicio (YYYY-MM-DD)'
    )
    parser.add_argument(
        '--fecha-fin',
        type=str,
        help='Fecha de fin (YYYY-MM-DD)'
    )
    parser.add_argument(
        '--dni',
        type=str,
        help='DNI espec√≠fico a procesar'
    )
    
    args = parser.parse_args()
    
    # Determinar rango de fechas
    if not args.fecha_inicio and not args.fecha_fin:
        # Por defecto: ayer
        fecha_inicio = datetime.now().date() - timedelta(days=1)
        fecha_fin = fecha_inicio
        print("üìå Sin par√°metros: procesando fecha de ayer")
    else:
        fecha_inicio = datetime.strptime(args.fecha_inicio, '%Y-%m-%d').date() if args.fecha_inicio else datetime.now().date() - timedelta(days=1)
        fecha_fin = datetime.strptime(args.fecha_fin, '%Y-%m-%d').date() if args.fecha_fin else fecha_inicio
    
    print(f"\n{'='*60}")
    print(f"  PROCESAMIENTO DE ASISTENCIA")
    print(f"{'='*60}")
    print(f"Per√≠odo: {fecha_inicio} al {fecha_fin}")
    if args.dni:
        print(f"DNI: {args.dni}")
    print(f"{'='*60}")
    
    # Conectar a BD
    conn = conectar_bd()
    
    try:
        total_procesados = 0
        fecha_actual = fecha_inicio
        
        while fecha_actual <= fecha_fin:
            procesados = procesar_fecha(conn, fecha_actual, args.dni)
            total_procesados += procesados
            fecha_actual += timedelta(days=1)
        
        print(f"\n{'='*60}")
        print(f"‚úÖ Proceso completado")
        print(f"   Total registros procesados: {total_procesados}")
        print(f"{'='*60}\n")
        
    except Exception as e:
        print(f"\n‚ùå Error durante el procesamiento: {e}")
        conn.rollback()
    finally:
        conn.close()


if __name__ == '__main__':
    main()
